const fs = require('fs');
const crypto = require('crypto');
const algorithm = 'aes-256-cbc'; //Using AES encryption
const key = crypto.randomBytes(32);
const iv = crypto.randomBytes(16);

module.exports = {
    getDefaultValueOnNull(val, defaultValue = null){
        if(val !== null && val !== undefined){
            return val;
        }
        return defaultValue != null ? defaultValue : '';
    },
    getBoolean(val){
        val = val !== undefined ? val.toString().toLowerCase().trim() : false;
        switch (val) {
            case "true":
            case true:
            case "1":
                return true;
            case "false":
            case false:
            case "0":
                return false;
            default:
                Boolean(val);
        }
    },
    deleteFileIfExists: (path) => {
        return new Promise((callback) => {
            fs.access(path, fs.F_OK, (err) => {
                if(err){
                    //file does not exists
                    return callback(false);
                }
                //file exists need to delete
                fs.unlink(path, (err) => {
                    if(err){
                        return callback(false);
                    }
                    callback(true);
                });
            });
        });
    },
    reviewStatusConstrains : {
        pendingForApproval : 'pending_for_approval',
        approved : 'approved',
        hidden : 'hidden',
        deleted : 'deleted',
    },
    inquiryStatusConstrains : {
        deleted : 0,
        initiated : 1,
        sent : 2,
        inProgress : 3,
        processed : 4,
    },
    encrypt: (text) =>{
        let cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key), iv);
        let encrypted = cipher.update(text);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        return { iv: iv.toString('hex'), encryptedData: encrypted.toString('hex') };
    },
    decrypt: (text) =>{
        let iv = Buffer.from(text.iv, 'hex');
        let encryptedText = Buffer.from(text.encryptedData, 'hex');
        let decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(key), iv);
        let decrypted = decipher.update(encryptedText);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return decrypted.toString();
    }
};